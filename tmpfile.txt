import Link from "next/link";

import { ArrowUpRight, Sparkles } from "lucide-react";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { createServerClient, type SupabaseClient } from "@/lib/supabase";
import { getActiveTenantId } from "@/server/server-actions";

import { AnalyticsKpiGrid } from "./_components/analytics-kpi-grid";
import { FunnelChartCard } from "./_components/funnel-chart-card";
import { LopShareDonutCard } from "./_components/lop-share-donut-card";
import { LopVsTargetCard } from "./_components/lop-vs-target-card";
import { QualifiedVsTargetCard } from "./_components/qualified-vs-target-card";
import { AnalyticsEmptyState, AnalyticsErrorState, UploadCta } from "./_components/states";
import { STAGE_ORDER, sortByStageOrder, type FunnelRow, type LopRow } from "./_components/utils";

const YEAR = 2026;

const normalizeStage = (stage: string | null | undefined): string =>
  typeof stage === "string" ? stage.trim().toLowerCase() : "";

const toNumber = (value: number | string | null | undefined): number => {
  if (value === null || value === undefined) return 0;
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : 0;
};

type AnalyticsData = {
  totalSegmentRow?: LopRow;
  aggregatedTotalLop?: LopRow;
  perSegmentLop: LopRow[];
  totalFunnelByStage: { stage: string; value: number; projects: number }[];
  totalProjects: number;
  funnelErrorMessage: string | null;
  lopErrorMessage: string | null;
  allEmpty: boolean;
};

type QueryResult<T> = {
  rows: T[];
  errorMessage: string | null;
};

const fetchFunnelRows = async (supabase: SupabaseClient, tenantId: string): Promise<QueryResult<FunnelRow>> => {
  const { data, error } = await supabase
    .from("vw_funnel_kpi_per_segment")
    .select("segment, stage, project_count, total_m, year")
    .eq("tenant_id", tenantId)
    .eq("year", YEAR);

  const rows = (data ?? []).map((row) => ({ ...row, stage: normalizeStage(row.stage) })) as FunnelRow[];

  return { rows, errorMessage: error?.message ?? null };
};

const fetchLopRows = async (supabase: SupabaseClient, tenantId: string): Promise<QueryResult<LopRow>> => {
  const { data, error } = await supabase
    .from("vw_lop_vs_target_per_segment")
    .select(
      "segment, year, target_rkap_m, target_stg_m, kecukupan_lop_m, qualified_lop_m, kecukupan_vs_rkap_pct, qualified_vs_rkap_pct",
    )
    .eq("tenant_id", tenantId)
    .eq("year", YEAR);

  return { rows: (data ?? []) as LopRow[], errorMessage: error?.message ?? null };
};

const calculatePercentage = (numerator: number | null | undefined, denominator: number | null | undefined) => {
  const safeNumerator = toNumber(numerator);
  const safeDenominator = toNumber(denominator);

  if (safeDenominator === 0) {
    return 0;
  }

  return (safeNumerator / safeDenominator) * 100;
};

const aggregateLopData = (
  lopRows: LopRow[],
): Pick<AnalyticsData, "perSegmentLop" | "aggregatedTotalLop" | "totalSegmentRow"> => {
  const perSegmentLop = lopRows.filter((row) => row.segment && row.segment !== "Total");
  const aggregatedTotalLop =
    perSegmentLop.length === 0
      ? undefined
      : perSegmentLop.reduce<LopRow>(
          (acc, row) => ({
            ...acc,
            target_rkap_m: acc.target_rkap_m + toNumber(row.target_rkap_m),
            target_stg_m: acc.target_stg_m + toNumber(row.target_stg_m),
            kecukupan_lop_m: acc.kecukupan_lop_m + toNumber(row.kecukupan_lop_m),
            qualified_lop_m: acc.qualified_lop_m + toNumber(row.qualified_lop_m),
          }),
          {
            segment: "Total",
            year: YEAR,
            target_rkap_m: 0,
            target_stg_m: 0,
            kecukupan_lop_m: 0,
            qualified_lop_m: 0,
            kecukupan_vs_rkap_pct: null,
            kecukupan_vs_stg_pct: null,
            qualified_vs_rkap_pct: null,
            qualified_vs_stg_pct: null,
          },
        );

  if (aggregatedTotalLop) {
    aggregatedTotalLop.kecukupan_vs_rkap_pct = calculatePercentage(
      aggregatedTotalLop.kecukupan_lop_m,
      aggregatedTotalLop.target_rkap_m,
    );
    aggregatedTotalLop.kecukupan_vs_stg_pct = calculatePercentage(
      aggregatedTotalLop.kecukupan_lop_m,
      aggregatedTotalLop.target_stg_m,
    );
    aggregatedTotalLop.qualified_vs_rkap_pct = calculatePercentage(
      aggregatedTotalLop.qualified_lop_m,
      aggregatedTotalLop.target_rkap_m,
    );
    aggregatedTotalLop.qualified_vs_stg_pct = calculatePercentage(
      aggregatedTotalLop.qualified_lop_m,
      aggregatedTotalLop.target_stg_m,
    );
  }

  const totalSegmentRow = lopRows.find((row) => row.segment === "Total") ?? aggregatedTotalLop;

  return { perSegmentLop, aggregatedTotalLop, totalSegmentRow };
};

const aggregateFunnelData = (
  funnelRows: FunnelRow[],
): Pick<AnalyticsData, "totalFunnelByStage" | "totalProjects"> => {
  const baseFunnelRows = funnelRows.filter((row) => row.segment && row.segment !== "Total");
  const funnelRowsForAggregation = baseFunnelRows.length > 0 ? baseFunnelRows : funnelRows;

  const totalFunnelByStage = sortByStageOrder(
    funnelRowsForAggregation.reduce<{ stage: string; value: number; projects: number }[]>((acc, row) => {
      const stageKey = normalizeStage(row.stage);
      if (!stageKey) return acc;
      const existing = acc.find((item) => item.stage === stageKey);
      if (existing) {
        existing.value += toNumber(row.total_m);
        existing.projects += Math.round(toNumber(row.project_count));
        return acc;
      }
      acc.push({
        stage: stageKey,
        value: toNumber(row.total_m),
        projects: Math.round(toNumber(row.project_count)),
      });
      return acc;
    }, []),
  );

  const totalProjects = totalFunnelByStage.reduce((sum, item) => sum + item.projects, 0);

  return { totalFunnelByStage, totalProjects };
};

const loadAnalyticsData = async (): Promise<AnalyticsData> => {
  const supabase = await createServerClient();
  const tenantId = await getActiveTenantId();

  const [funnelResult, lopResult] = await Promise.all([
    fetchFunnelRows(supabase, tenantId),
    fetchLopRows(supabase, tenantId),
  ]);

  const { perSegmentLop, aggregatedTotalLop, totalSegmentRow } = aggregateLopData(lopResult.rows);
  const { totalFunnelByStage, totalProjects } = aggregateFunnelData(funnelResult.rows);

  const funnelErrorMessage = funnelResult.errorMessage;
  const lopErrorMessage = lopResult.errorMessage;
  const hasError = Boolean(funnelErrorMessage ?? lopErrorMessage);
  const allEmpty = !hasError && funnelResult.rows.length === 0 && lopResult.rows.length === 0;

  return {
    totalSegmentRow,
    aggregatedTotalLop,
    perSegmentLop,
    totalFunnelByStage,
    totalProjects,
    funnelErrorMessage,
    lopErrorMessage,
    allEmpty,
  };
};

export default async function AnalyticsPage() {
  const {
    totalSegmentRow,
    aggregatedTotalLop,
    perSegmentLop,
    totalFunnelByStage,
    totalProjects,
    funnelErrorMessage,
    lopErrorMessage,
    allEmpty,
  } = await loadAnalyticsData();

  return (
    <div className="container mx-auto space-y-8 px-2 py-4 sm:px-4 md:px-0">
      <div className="flex flex-col gap-3 rounded-3xl border border-slate-200 bg-white p-6 shadow-lg shadow-slate-900/10 dark:border-slate-800 dark:bg-slate-950">
        <div className="flex flex-wrap items-center justify-between gap-4">
          <div className="space-y-2">
            <div className="inline-flex items-center gap-2 rounded-full border border-slate-200/80 bg-white/80 px-3 py-1 text-xs font-semibold tracking-[0.2em] text-slate-600 uppercase shadow-sm dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-200">
              <Sparkles className="h-4 w-4 text-indigo-500" />
              Analytics
            </div>
            <div className="flex flex-wrap items-center gap-3">
              <h1 className="text-3xl leading-tight font-bold text-slate-900 dark:text-slate-50">
                Analytics {YEAR}
              </h1>
              <Badge variant="secondary" className="bg-indigo-50 text-indigo-700 shadow-sm dark:bg-indigo-900/40 dark:text-indigo-100">
                STAGE ORDER: {STAGE_ORDER.join(" -> ")}
              </Badge>
            </div>
            <p className="max-w-3xl text-sm text-slate-600 dark:text-slate-300">
              LOP & funnel overview untuk seluruh segmen menggunakan nilai {YEAR}. Visual modern dengan gradient halus
              dan insight yang siap dibagikan.
            </p>
          </div>
          <Button asChild variant="outline" className="gap-2">
            <Link href="/add-data">
              Tambah Data
              <ArrowUpRight className="h-4 w-4" />
            </Link>
          </Button>
        </div>
      </div>

      {allEmpty ? (
        <div className="space-y-3">
          <AnalyticsEmptyState message="Belum ada data funnel atau LOP untuk ditampilkan. Unggah data terlebih dahulu." />
          <UploadCta />
        </div>
      ) : (
        <>
          {lopErrorMessage ? (
            <AnalyticsErrorState message={lopErrorMessage} />
          ) : (
            <AnalyticsKpiGrid totalRow={totalSegmentRow} year={YEAR} />
          )}

          <div className="grid grid-cols-1 gap-6 xl:grid-cols-2">
            <FunnelChartCard data={totalFunnelByStage} totalProjects={totalProjects} error={funnelErrorMessage} />
            <LopVsTargetCard data={perSegmentLop} year={YEAR} error={lopErrorMessage} />
            <LopShareDonutCard
              data={perSegmentLop}
              totalValue={aggregatedTotalLop?.kecukupan_lop_m ?? totalSegmentRow?.kecukupan_lop_m ?? 0}
              year={YEAR}
              error={lopErrorMessage}
            />
            <QualifiedVsTargetCard data={perSegmentLop} error={lopErrorMessage} />
          </div>
        </>
      )}
    </div>
  );
}

